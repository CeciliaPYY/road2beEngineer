# 2.4 算法和数据结构操作
有很多算法都可以用递归和循环两种不同的方式实现。通常基于递归地方法代码会比较简洁，但它的性能不如基于循环的方法。面试的时候，可以基于题目的特点，和面试官讨论选择合适的方法编程。

通常查找和排序是面试考察的重点，其中应该重点掌握**二分查找**，**归并排序**和**快速排序**，做到能随时正确、准确地写出它们的代码。

若面试题要求在二维数组（可能具体表现为棋盘或者迷宫）上搜索路径，那么我们可以尝试**回溯法**

    回溯法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。“回溯法”是一种选优搜索法，按选优条件向前搜索，以达到目标。

通常回溯法很适合递归代码的实现。只有当面试官限定不可以用递归实现的时候，我们再考虑用栈来模拟递归过程。

如果面试题是求某个问题的最优解，并且该问题可以分为多个子问题。那么我们可以尝试**动态规划**。

如果我们告诉面试官动态规划的思路之后，面试官还在提醒说分解子问题的时候是否存在某个特殊的选择，如果采用这个特殊的选择将一定能得到最优解，那么只意味着该面试题可能最适用于贪婪算法。

位运算是把数字表示成二进制之后对 0 和 1 的操作，位运算总共只有与、或、异或、左移和右移5种运算。

### 2.4.2 查找和排序
#### 查找
查找相对而言比较简单，不外乎顺序查找、二分查找、哈希表查找和二叉树排序查找。面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出完整正确的二分查找代码。

如果面试题要求是在排序的数组（或者部分排序的数组）中**查找一个数字**或者**统计某个数字出现的次数**，那么我们都可以尝试用二分查找算法。

哈希表和二叉排序树查找的重点在于考察对应的数据结构而不是算法。哈希表最主要的特点是我们利用它能够在 O(1) 时间内查找某一元素，是效率最高的查找方式；但其缺点是需要额外的空间来实现哈希表。

与二叉排序树查找算法对应的数据结构是二叉搜索树。

#### 排序
排序比查找要复杂一些，面试经常会要求比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。
在面试的时候一定要对各种排序算法的特点烂熟于胸，能够从**额外空间消耗**、**平均时间复杂度**和**最差时间复杂度**方面去比较它们的优缺点。

![image](https://github.com/CeciliaPYY/road2beEngineer/raw/master/thorn2offer/images/sort.jpeg)

很多公司都喜欢在面试环节要求应聘者写出快速排序的代码。

### 2.4.3 回溯法
回溯法可以看成蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合**由多个步骤组成的问题，并且每个步骤都有多个选项**。

用回溯法解决的问题的所有选项可以形象地用**树状结构**表示。在某一步有n个可能的选项，那么该步骤可以看做是树状结构中的一个节点，每个选项看成书中节点连接线，经过这些连接线到达该节点的n个子节点。树的**叶结点**对应着**终结状态**。如果在叶结点的状态满足题目的结束条件，那么我们找到了一个可行的解决方案。

那么如果在叶结点的状态不满足题目的结束条件，我们该怎么办呢？

那么我们只好回溯到上一个结点尝试其他的选项。如果上一个结点的所有可能选项都已经尝试过，并且不能到达满足条件的约束状态，则再次回溯到上一个节点。如果所有结点的选项都已经尝试过仍然不能满足约束条件的终结状态，那么这个问题就是无解的了。

通常回溯算法适合用**递归**实现代码。当我们到达某一个节点时，尝试所有可能的选项并在满足条件的前提下递归地抵达下一个节点。