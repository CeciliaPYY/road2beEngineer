# 2.4 算法和数据结构操作
有很多算法都可以用递归和循环两种不同的方式实现。通常基于递归地方法代码会比较简洁，但它的性能不如基于循环的方法。面试的时候，可以基于题目的特点，和面试官讨论选择合适的方法编程。

通常查找和排序是面试考察的重点，其中应该重点掌握**二分查找**，**归并排序**和**快速排序**，做到能随时正确、准确地写出它们的代码。

若面试题要求在二维数组（可能具体表现为棋盘或者迷宫）上搜索路径，那么我们可以尝试**回溯法**

    回溯法实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。“回溯法”是一种选优搜索法，按选优条件向前搜索，以达到目标。

通常回溯法很适合递归代码的实现。只有当面试官限定不可以用递归实现的时候，我们再考虑用栈来模拟递归过程。

如果面试题是求某个问题的最优解，并且该问题可以分为多个子问题。那么我们可以尝试**动态规划**。

如果我们告诉面试官动态规划的思路之后，面试官还在提醒说分解子问题的时候是否存在某个特殊的选择，如果采用这个特殊的选择将一定能得到最优解，那么只意味着该面试题可能最适用于贪婪算法。

位运算是把数字表示成二进制之后对 0 和 1 的操作，位运算总共只有与、或、异或、左移和右移5种运算。

### 2.4.2 查找和排序
#### 查找
查找相对而言比较简单，不外乎顺序查找、二分查找、哈希表查找和二叉树排序查找。面试的时候，不管是用循环还是递归，面试官都期待应聘者能够信手拈来写出完整正确的二分查找代码。

如果面试题要求是在排序的数组（或者部分排序的数组）中**查找一个数字**或者**统计某个数字出现的次数**，那么我们都可以尝试用二分查找算法。

哈希表和二叉排序树查找的重点在于考察对应的数据结构而不是算法。哈希表最主要的特点是我们利用它能够在 O(1) 时间内查找某一元素，是效率最高的查找方式；但其缺点是需要额外的空间来实现哈希表。

与二叉排序树查找算法对应的数据结构是二叉搜索树。

#### 排序
排序比查找要复杂一些，面试经常会要求比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。
在面试的时候一定要对各种排序算法的特点烂熟于胸，能够从**额外空间消耗**、**平均时间复杂度**和**最差时间复杂度**方面去比较它们的优缺点。

![image](https://github.com/CeciliaPYY/road2beEngineer/raw/master/thorn2offer/images/sort.jpeg)

很多公司都喜欢在面试环节要求应聘者写出快速排序的代码。

### 2.4.3 回溯法
回溯法可以看成蛮力法的升级版，它从解决问题每一步的所有可能选项里系统地选择出一个可行的解决方案。回溯法非常适合**由多个步骤组成的问题，并且每个步骤都有多个选项**。

用回溯法解决的问题的所有选项可以形象地用**树状结构**表示。在某一步有n个可能的选项，那么该步骤可以看做是树状结构中的一个节点，每个选项看成书中节点连接线，经过这些连接线到达该节点的n个子节点。树的**叶结点**对应着**终结状态**。如果在叶结点的状态满足题目的结束条件，那么我们找到了一个可行的解决方案。

那么如果在叶结点的状态不满足题目的结束条件，我们该怎么办呢？

那么我们只好回溯到上一个结点尝试其他的选项。如果上一个结点的所有可能选项都已经尝试过，并且不能到达满足条件的约束状态，则再次回溯到上一个节点。如果所有结点的选项都已经尝试过仍然不能满足约束条件的终结状态，那么这个问题就是无解的了。

通常回溯算法适合用**递归**实现代码。当我们到达某一个节点时，尝试所有可能的选项并在满足条件的前提下递归地抵达下一个节点。

### 2.4.4 动态规划与贪婪算法
#### 动态规划（**）
如果面试题是求一个问题的最优解（通常是求最大值或最小值），而且该问题能够分解成若干个子问题，并且子问题之间还有重叠的更小子问题，就可以考虑用动态规划来解决这个问题。

可用动态规划求解的问题具有的特点：
1. 求一个问题的最优解；

2. 整体问题的最优解是依赖各个子问题的最优解；

3. 把大问题分解成若干个小问题，这些小问题之间还有相互重叠的更小的子问题；

4. 从上往下分析问题，从下往上求解问题；
   
在应用动态规划解决问题的时候，我们总是从解决最小问题开始，并把已经解决的子问题的最优解存储下来（大部分面试题都是存储在一维或者二维数组里），并把子问题的最优解组合起来解决大的问题。

#### 贪婪算法
贪婪算法和动态规划不一样。当我们应用贪婪算法解决问题的时候，每一步都可以做出一个贪婪的选择，基于这个选择，我们确定能够得到最优解。为什么这种贪婪的选择可以得到最优解呢？这是我们应用贪婪算法时都需要问的问题，需要用数学方式来证明贪婪选择是正确的。
   
### 2.4.5 位运算
位运算是把数字用二进制表示之后，对每一位上 0 或者 1 的运算。

在程序员圈子里有一则流传了很久的笑话，说世界上有 10 种人，一种知道二进制，一种则不知道二进制...

下面是一道很新颖的关于进制的题目：

在微软产品 Excel 中，用 A 表示第 1 列，B 表示第 2 列，...，Z 表示第 26 列，AA 表示第 27 列，AB 表示第 28 列...以此类推。请写出一个函数，输入用字母表示的列号编码，输出它是第几列。

这道题的本质是把十进制数字用 A~Z 表示成二十六进制。
代码见()

二进制的位运算只有 5 种运算，他们分别是与运算，或运算，异或运算，左移运算以及右移运算。

与运算（&）

规则是：两个数字相同则为 1，不同则为 0；

或运算（|）

规则是：只有两个数字都是 0 的时候才为0；

异或运算（^）

规则是：两个数字相同则为 0，不同则为 1；

左移运算（m << n）

规则是：左移 n 位的时候，最左边的 n 位将会被抛弃，而最右边则会补上 n 个 0；

右移运算（m >> n）

规则是：在右移 n 位的时候，最右边的 n 位将会被抛弃，但右移时处理最左边的情形要稍微复杂一些。如果数字是一个无符号数值，则用 0 填补最左边的 n 位；如果数字是一个有符号数值，则用数字的符号填补最左边的数值。

比如，

00001010 >> 2 = 00000010

但是，

10001010 >> 3 = 11110001

注意：把一个整数减去 1 之后再和原来的整数做位与运算，得到的结果相当于把整数的二进制表示中最右边的 1 变为 0.很多二进制的问题都可以利用这种思路解决。